## 組み込み関数
### 日時編
#### `mktime(時, 分, 秒, 月, 日, 年) //並びは意外と直感的`  
タイムスタンプ――UNIX基準時からの総秒数――を取得  
ちなみに`time()`は引数を取らない一番原始的な形  
mktimeでも省略可能だけど厳密にはダメらしい　makeなんだしね  
[https://secure.php.net/manual/ja/function.mktime.php]

#### `date('フォーマット' [,$timestamp] )`  
> ローカルの日付/時刻を書式化する。

指定したフォーマットで返してくれる　フォーマットを必ず渡さないとダメらしい  
後半を指定すれば指定時刻　intだから事前にタイムスタンプ型（整数型）を録っておかないとダメだよ　デフォルトは空＝現在時刻  
フォーマットには定義済みの定数もあるそうな  
[https://secure.php.net/manual/ja/function.date.php]

#### `array getdate ([$timestamp] )`  
> 日付情報を有する連想配列を返します。

#### `strtotime('+1 day'　[,$timestamp]) `  
`int strtotime ( string $time [, int $now = time() ] )`
> 英文形式の日付を Unix タイムスタンプに変換する  

「英文形式の」ってのは、[サポートする日付と時刻の表示](http://php.net/manual/ja/datetime.formats.php)の特に「相対的な書式」にある自然言語っぽい書き方を操作文字列として受け付けるよってこと  
指定時刻は整数型じゃないとダメなんだから、自然言語による操作こそが主眼の関数なのでは


### 文字列編
#### `strlen(str)`
> 与えられた string の長さを返します。
> strlen() が返すのはバイト数であり、 文字数ではありません。 

##### `mb_strlen()`
マルチバイト対応、文字数を返す

#### `substr()`  
`string substr ( string $string , int $start [, int $length ] )`
> 文字列の一部分を返す

カウントは0から

##### `mb_substr()`

#### `trim(str)`  
`string trim ( string $str [, string $character_mask = " \t\n\r\0\x0B" ] )`
> 文字列の先頭および末尾にあるホワイトスペースを取り除く

つまり行中の空白は除去しない

#### `int strcmp(str1, str2)`  
> バイナリセーフな文字列比較
> str1 が str2 よりも小さければ < 0 を、str1が str2よりも大きければ > 0 を、 等しければ 0 を返します。

比較というか差というか（※ただしほぼ同一な文字列に限る）  
「何文字一致してるか」を返す  
-1がfalseにあたる  
まあバイナリだから

#### `strpos()`  
> 文字列内の部分文字列が最初に現れる場所を見つける

`mixed strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )`  
返り値がmixedなのは数値かfalseを返すから

#### `strstr('soeda-r@groove-gear.jp', '@')`  
> 文字列が最初に現れる位置を見つける

と言っているが

> haystack の中で needle が最初に現れる場所を含めてそこから文字列の終わりまでを返します。

要は*指定文字列以降を取得する*  
`string strstr ( string $haystack , mixed $needle [, bool $before_needle = false ] )`

#### `str_replace('を検索', 'に置換', '対象の')`  
`mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )`  
countは何個置換したかを格納してくれる

#### explode＆implode

```php
$sample = 'aaa, bbb, ccc, ddd';
$arr = explode(',', $sample);
$str = implode(',', $arr);
```

`array explode ( string $delimiter , string $string [, int $limit = PHP_INT_MAX ] )`  
`string implode ( string $glue , array $pieces )`

特定の文字を対象に文字列を分割し、配列として返す　implodeはその逆  
CSVファイル（カンマ区切り）⇔エクセルファイル みたいなもんだ

### ファイル編

```php
// ファイルを書き込みモードで開く
$fp = fopen('xxx.txt', 'w');
// 書き込み操作 ― 1行書き込み
fwrite($fp, 'www');
// ファイルを閉じる
fclose($fp);
```

ファイルは開いたら閉じましょう  
- [ ] メモリ管理に関係するらしい
#### `fopen()`
`resource fopen ( string $filename , string $mode [, bool $use_include_path = false [, resource $context ]] )`;  
r：読み取り w：書き込み a：追記
ファイルが存在しなければ作成してくれる
URLも使えるらしい

#### `fgets()`
`string fgets ( resource $handle [, int $length ] )`  
1行限定

#### `fclose()`

#### `file_get_contents()`
`string file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = 0 [, int $maxlen ]]]] )`  
> ファイルの内容を全て文字列に読み込む

#### `file_put_contetns()`
`int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] )`  
> 文字列をファイルに書き込む
